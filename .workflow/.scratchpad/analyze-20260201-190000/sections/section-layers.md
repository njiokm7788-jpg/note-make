## 系统架构设计报告 - 逻辑视点与分层架构

### 分层架构概述

该图像处理系统采用经典的四层分层架构，从下至上依次为入口点层、表现层、编排层和业务逻辑层。这一架构设计围绕关注点分离的核心理念展开，通过明确的层级边界和单向依赖关系，确保系统的可维护性、可测试性和可扩展性。各层职责明确，边界清晰，形成了一个高内聚、低耦合的系统结构。

### 职责分配体系

**入口点层**作为系统与运行环境的唯一接触点，其核心职责在于应用程序的初始化和全局样式配置。该层通过 React 的 StrictMode 包装确保开发环境下的严格检查，并将根组件挂载到 DOM 中。这一层的设计极其简洁，仅承担引导职责，不涉及任何业务逻辑，体现了单一职责原则的严格遵循。

**表现层**由九个专业化的 UI 组件组成，包括 Sidebar、FloatingUploadButton、UploadStatusBar、UploadModal、UploadDrawer、ImageUploader、ImagePreview、ProcessingPanel 和 BatchProcessor。该层的核心职责是将用户交互转化为事件信号，并将应用状态渲染为可视化界面。每个组件都专注于特定的 UI 功能域，通过 Props 接收数据和回调函数，形成了一个高度模块化的表现层。值得注意的是，表现层组件之间不存在直接的数据流动，所有通信都通过编排层进行中转，这一设计确保了组件的独立性和可复用性。

**编排层**由 App.tsx 单独承担，是系统的中枢神经。该层的职责包括全局状态管理、组件生命周期协调、事件分发和业务逻辑调用。App.tsx 维护着应用的核心状态，包括处理模式（单图或批量）、上传文件、处理选项、用户预设、UI 状态和处理进度等。通过 React Hooks（useState、useEffect、useCallback、useRef）的组合使用，该层实现了复杂的状态管理逻辑。此外，编排层还实现了响应式设计的适配逻辑，通过 useScreenSize 自定义 Hook 监听媒体查询变化，根据屏幕尺寸动态调整 UI 布局。编排层的另一个关键职责是持久化管理，通过 localStorage 存储用户偏好设置（如侧边栏折叠状态、选中预设），实现跨会话的状态保留。

**业务逻辑层**由两个专业化的工具模块组成：imageProcessor.ts 和 fileUtils.ts。imageProcessor.ts 封装了图像处理的核心算法，包括文字区域检测、遮罩膨胀、色块应用等复杂的像素级操作。该模块还管理预设方案的生命周期，提供了加载、添加、删除、更新和重置预设的完整接口。fileUtils.ts 则专注于文件操作，包括单个结果下载、批量结果打包、文件验证和大小格式化等功能。这两个模块共同构成了系统的计算核心，与表现层完全解耦。

### 数据流向与约束

系统遵循严格的单向数据流模式，形成了清晰的信息传递路径。从顶层来看，用户交互首先被表现层捕获，通过回调函数向上传递至编排层。编排层接收这些事件信号后，更新内部状态，并根据新状态调用业务逻辑层的函数。业务逻辑层处理完毕后，将结果返回给编排层，编排层再将结果通过 Props 向下传递给表现层进行渲染。这一流程形成了一个完整的闭环，不存在跨层的直接通信。

具体而言，当用户上传图像文件时，表现层的 UploadModal 组件捕获文件选择事件，通过 onOriginalSelect 或 onAnnotatedSelect 回调将文件对象传递给编排层。编排层更新 originalFile 或 annotatedFile 状态，同时触发 useEffect 中的自动预览逻辑。该逻辑调用业务逻辑层的 generatePreview 函数，该函数返回处理后的图像数据。编排层接收预览结果后，更新 previewResult 状态，表现层的 ImagePreview 组件订阅此状态变化，重新渲染预览区域。这一过程中，数据严格遵循单向流动，不存在反向的状态修改。

在处理选项的流向上，用户在 Sidebar 组件中调整参数，通过 onChange 回调将新的 ProcessingOptions 对象传递给编排层。编排层更新 options 状态，同时通过 useDebounce Hook 对频繁的参数变化进行防抖处理，避免过度的预览计算。防抖后的选项值触发 useEffect，再次调用业务逻辑层的预览函数。这一设计体现了对性能的精细化管理。

### 边界隔离策略

系统通过多种机制实现了层级间的有效隔离。首先，接口抽象是隔离的基础。业务逻辑层导出了明确定义的 TypeScript 接口（ProcessingOptions、Preset），表现层和编排层通过这些接口与业务逻辑层交互，而不依赖于实现细节。例如，imageProcessor.ts 导出的 generatePreview 函数接收标准化的 ProcessingOptions 对象，无论调用者如何构造这个对象，函数的行为都是确定的。

其次，数据转换层确保了下层实现细节的隐藏。fileUtils.ts 中的 downloadSingleResult 函数接收 File 对象和 ProcessingOptions，内部调用 processImagePair 进行处理，最后通过 file-saver 库的 saveAs 函数触发下载。这一过程中，表现层完全不需要了解文件系统 API 或 Blob 对象的细节，所有复杂性都被封装在业务逻辑层内部。

再次，依赖注入模式被广泛应用于状态管理。编排层通过 Props 向表现层注入所需的状态和回调函数，表现层组件无需直接访问全局状态或 localStorage，所有数据都通过 Props 显式传递。这一设计使得表现层组件高度独立，可以在不同的上下文中复用。

此外，localStorage 的访问被严格限制在编排层和业务逻辑层。表现层组件不直接操作 localStorage，所有持久化操作都通过编排层的中介进行。这一约束确保了表现层的纯净性，使其专注于 UI 渲染和事件处理。

### 异常处理流

系统的异常处理遵循分层的原则，不同层级采用不同的处理策略。在业务逻辑层，imageProcessor.ts 中的图像处理函数采用防御性编程，对输入参数进行验证。例如，parseColor 函数对 CSS 颜色值进行格式检查，若格式不符合预期，则返回默认的黄色。extractTextMask 函数对膨胀半径进行边界检查，确保不会产生越界访问。这一层的异常处理主要关注数据有效性和算法的鲁棒性。

在编排层，App.tsx 通过 try-catch 块捕获 localStorage 的访问异常。readPersistedCollapsed 和 readPersistedPreset 函数在 JSON 解析失败时返回 undefined，编排层随后使用默认值进行降级处理。这一设计确保了即使本地存储损坏，应用仍能正常启动。此外，编排层通过 isProcessing 状态标志管理处理过程中的异常，当处理失败时，该标志被重置为 false，UI 恢复到可交互状态。

在表现层，组件通过条件渲染处理异常状态。例如，ImagePreview 组件在预览数据不可用时显示占位符，UploadStatusBar 组件根据上传状态显示不同的提示信息。表现层的异常处理主要关注用户反馈和 UI 状态的一致性。

跨层的异常传递遵循以下规则：业务逻辑层的异常首先被编排层捕获，编排层决定是否将异常信息转化为用户可见的反馈。例如，批量处理中某个文件处理失败时，fileUtils.ts 中的 downloadBatchResults 函数通过 console.error 记录错误，但继续处理后续文件，确保整个批处理流程不中断。编排层可以根据需要将这些错误信息转化为 Toast 提示，通知用户处理结果。

### 架构优势与设计原则

这一分层架构的设计体现了多个软件设计原则的应用。单一职责原则确保了每一层都有明确的职责边界，表现层专注于 UI，编排层专注于状态管理，业务逻辑层专注于算法实现。开闭原则通过接口抽象得以体现，新增处理算法或 UI 组件时，无需修改现有层的代码，仅需扩展相应的模块。依赖倒置原则通过 Props 注入和回调函数实现，上层不依赖下层的具体实现，而是依赖于抽象的接口。

这一架构为系统的演进提供了坚实的基础。若需要添加新的处理模式，仅需在业务逻辑层扩展 imageProcessor.ts，编排层通过新增状态和条件逻辑进行适配，表现层通过新增组件进行展示，各层的改动相对独立。若需要替换文件下载的实现方式，仅需修改 fileUtils.ts，编排层和表现层无需感知。这一特性使得系统具有良好的可维护性和可扩展性。
